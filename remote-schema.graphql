# This file was generated based on ".graphqlconfig". Do not edit manually.

schema {
    query: Query
    mutation: Mutation
}

"An object with an ID"
interface Node {
    "The id of the object."
    id: ID!
    "The Stage of an object"
    stage: Stage!
}

type Agent implements Node {
    "The time the document was created"
    createdAt: DateTime!
    "Get the document in other stages"
    documentInStages(
        #Decides if the current stage should be included or not
        includeCurrent: Boolean! = false,
        #Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree
        inheritLocale: Boolean! = false,
        #Potential stages that should be returned
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Agent!]!
    hand(after: String, before: String, first: Int, last: Int, orderBy: CardOrderByInput, skip: Int, where: CardWhereInput): [Card!]!
    "The unique identifier"
    id: ID!
    name: String!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
}

"A connection to a list of items."
type AgentConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [AgentEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AgentEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Agent!
}

type Aggregate {
    count: Int!
}

"Asset system model"
type Asset implements Node {
    cardImage(after: String, before: String, first: Int, last: Int, orderBy: CardOrderByInput, skip: Int, where: CardWhereInput): [Card!]!
    "The time the document was created"
    createdAt: DateTime!
    "Get the document in other stages"
    documentInStages(
        #Decides if the current stage should be included or not
        includeCurrent: Boolean! = false,
        #Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree
        inheritLocale: Boolean! = false,
        #Potential stages that should be returned
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Asset!]!
    "The file name"
    fileName: String!
    "The file handle"
    handle: String!
    "The height of the file"
    height: Float
    "The unique identifier"
    id: ID!
    "System Locale field"
    locale: Locale!
    "Get the other localizations for this document"
    localizations(
        #Decides if the current locale should be included or not
        includeCurrent: Boolean! = false,
        #Potential locales that should be returned
        locales: [Locale!]! = [en]
    ): [Asset!]!
    "The mime type of the file"
    mimeType: String
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "The file size"
    size: Float
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
    "Get the url for the asset with provided transformations applied."
    url(transformation: AssetTransformationInput): String!
    "The file width"
    width: Float
}

"A connection to a list of items."
type AssetConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [AssetEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type AssetEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Asset!
}

type BatchPayload {
    "The number of nodes that have been affected by the Batch operation."
    count: Long!
}

type Card implements Node {
    agent: Agent
    "The time the document was created"
    createdAt: DateTime!
    "Get the document in other stages"
    documentInStages(
        #Decides if the current stage should be included or not
        includeCurrent: Boolean! = false,
        #Decides if the documents should match the parent documents locale or should use the fallback order defined in the tree
        inheritLocale: Boolean! = false,
        #Potential stages that should be returned
        stages: [Stage!]! = [PUBLISHED, DRAFT]
    ): [Card!]!
    "The unique identifier"
    id: ID!
    image: Asset
    isDrawn: Boolean!
    name: String!
    "The time the document was published. Null on documents in draft stage."
    publishedAt: DateTime
    "System stage field"
    stage: Stage!
    "The time the document was updated"
    updatedAt: DateTime!
}

"A connection to a list of items."
type CardConnection {
    aggregate: Aggregate!
    "A list of edges."
    edges: [CardEdge!]!
    "Information to aid in pagination."
    pageInfo: PageInfo!
}

"An edge in a connection."
type CardEdge {
    "A cursor for use in pagination."
    cursor: String!
    "The item at the end of the edge."
    node: Card!
}

"Representing a color value comprising of HEX, RGBA and css color values"
type Color {
    css: String!
    hex: Hex!
    rgba: RGBA!
}

"Representing a geolocation point with latitude and longitude"
type Location {
    distance(from: LocationInput!): Float!
    latitude: Float!
    longitude: Float!
}

type Mutation {
    "Create one agent"
    createAgent(data: AgentCreateInput!): Agent
    "Create one asset"
    createAsset(data: AssetCreateInput!): Asset @deprecated(reason : "Asset mutations will be overhauled soon")
    "Create one card"
    createCard(data: CardCreateInput!): Card
    "Delete one agent from _all_ existing stages. Returns deleted document."
    deleteAgent(
        #Document to delete
        where: AgentWhereUniqueInput!
    ): Agent
    "Delete one asset from _all_ existing stages. Returns deleted document."
    deleteAsset(
        #Document to delete
        where: AssetWhereUniqueInput!
    ): Asset
    "Delete one card from _all_ existing stages. Returns deleted document."
    deleteCard(
        #Document to delete
        where: CardWhereUniqueInput!
    ): Card
    "Delete many Agent documents"
    deleteManyAgents(
        #Documents to delete
        where: AgentManyWhereInput
    ): BatchPayload!
    "Delete many Asset documents"
    deleteManyAssets(
        #Documents to delete
        where: AssetManyWhereInput
    ): BatchPayload!
    "Delete many Card documents"
    deleteManyCards(
        #Documents to delete
        where: CardManyWhereInput
    ): BatchPayload!
    "Publish one agent"
    publishAgent(
        #Publishing target stage
        to: [Stage!]! = [PUBLISHED],
        #Document to publish
        where: AgentWhereUniqueInput!
    ): Agent
    "Publish one asset"
    publishAsset(
        #Optional localizations to publish
        locales: [Locale!],
        #Publish base document including default localization and relations, as well as selected additional localizations. Returns document in mutation stage.
        publishBase: Boolean = true,
        #Publishing target stage
        to: [Stage!]! = [PUBLISHED],
        #Document to publish
        where: AssetWhereUniqueInput!
    ): Asset
    "Publish one card"
    publishCard(
        #Publishing target stage
        to: [Stage!]! = [PUBLISHED],
        #Document to publish
        where: CardWhereUniqueInput!
    ): Card
    "Publish many Agent documents"
    publishManyAgents(
        #Stages to publish documents to
        to: [Stage!]! = [PUBLISHED],
        #Identifies documents in each stage to be published
        where: AgentManyWhereInput
    ): BatchPayload!
    "Publish many Asset documents"
    publishManyAssets(
        #Document localizations to publish
        locales: [Locale!],
        #Whether to publish the base document and default localization
        publishBase: Boolean = true,
        #Stages to publish documents to
        to: [Stage!]! = [PUBLISHED],
        #Identifies documents in each stage to be published
        where: AssetManyWhereInput
    ): BatchPayload!
    "Publish many Card documents"
    publishManyCards(
        #Stages to publish documents to
        to: [Stage!]! = [PUBLISHED],
        #Identifies documents in each stage to be published
        where: CardManyWhereInput
    ): BatchPayload!
    "Unpublish one agent from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishAgent(
        #Stages to unpublish document from
        from: [Stage!]! = [PUBLISHED],
        #Document to unpublish
        where: AgentWhereUniqueInput!
    ): Agent
    "Unpublish one asset from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishAsset(
        #Stages to unpublish document from
        from: [Stage!]! = [PUBLISHED],
        #Optional locales to unpublish. Unpublishing the default locale will completely remove the document from the selected stages
        locales: [Locale!],
        #Unpublish complete document including default localization and relations from stages. Can be disabled.
        unpublishBase: Boolean = true,
        #Document to unpublish
        where: AssetWhereUniqueInput!
    ): Asset
    "Unpublish one card from selected stages. Unpublish either the complete document with its relations, localizations and base data or specific localizations only."
    unpublishCard(
        #Stages to unpublish document from
        from: [Stage!]! = [PUBLISHED],
        #Document to unpublish
        where: CardWhereUniqueInput!
    ): Card
    "Unpublish many Agent documents"
    unpublishManyAgents(
        #Stages to unpublish documents from
        from: [Stage!]! = [PUBLISHED],
        #Identifies documents in each stage
        where: AgentManyWhereInput
    ): BatchPayload!
    "Unpublish many Asset documents"
    unpublishManyAssets(
        #Stages to unpublish documents from
        from: [Stage!]! = [PUBLISHED],
        #Locales to unpublish
        locales: [Locale!],
        #Whether to unpublish the base document and default localization
        unpublishBase: Boolean = true,
        #Identifies documents in each stage
        where: AssetManyWhereInput
    ): BatchPayload!
    "Unpublish many Card documents"
    unpublishManyCards(
        #Stages to unpublish documents from
        from: [Stage!]! = [PUBLISHED],
        #Identifies documents in each stage
        where: CardManyWhereInput
    ): BatchPayload!
    "Update one agent"
    updateAgent(data: AgentUpdateInput!, where: AgentWhereUniqueInput!): Agent
    "Update one asset"
    updateAsset(data: AssetUpdateInput!, where: AssetWhereUniqueInput!): Asset
    "Update one card"
    updateCard(data: CardUpdateInput!, where: CardWhereUniqueInput!): Card
    "Update many agents"
    updateManyAgents(
        #Updates to document content
        data: AgentUpdateManyInput!,
        #Documents to apply update on
        where: AgentManyWhereInput
    ): BatchPayload!
    "Update many assets"
    updateManyAssets(
        #Updates to document content
        data: AssetUpdateManyInput!,
        #Documents to apply update on
        where: AssetManyWhereInput
    ): BatchPayload!
    "Update many cards"
    updateManyCards(
        #Updates to document content
        data: CardUpdateManyInput!,
        #Documents to apply update on
        where: CardManyWhereInput
    ): BatchPayload!
    "Upsert one agent"
    upsertAgent(upsert: AgentUpsertInput!, where: AgentWhereUniqueInput!): Agent
    "Upsert one asset"
    upsertAsset(upsert: AssetUpsertInput!, where: AssetWhereUniqueInput!): Asset
    "Upsert one card"
    upsertCard(upsert: CardUpsertInput!, where: CardWhereUniqueInput!): Card
}

"Information about pagination in a connection."
type PageInfo {
    "When paginating forwards, the cursor to continue."
    endCursor: String
    "When paginating forwards, are there more items?"
    hasNextPage: Boolean!
    "When paginating backwards, are there more items?"
    hasPreviousPage: Boolean!
    "When paginating backwards, the cursor to continue."
    startCursor: String
}

type Query {
    "Retrieve a single agent"
    agent(stage: Stage! = PUBLISHED, where: AgentWhereUniqueInput!): Agent
    "Retrieve multiple agents"
    agents(after: String, before: String, first: Int, last: Int, orderBy: AgentOrderByInput, skip: Int, stage: Stage! = PUBLISHED, where: AgentWhereInput): [Agent!]!
    "Retrieve multiple agents using the Relay connection interface"
    agentsConnection(after: String, before: String, first: Int, last: Int, orderBy: AgentOrderByInput, skip: Int, stage: Stage! = PUBLISHED, where: AgentWhereInput): AgentConnection!
    "Retrieve a single asset"
    asset(
        #First locale matched will be used based on the order of this input
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED,
        where: AssetWhereUniqueInput!
    ): Asset
    "Retrieve multiple assets"
    assets(
        after: String,
        before: String,
        first: Int,
        last: Int,
        #First locale matched will be used based on the order of this input
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): [Asset!]!
    "Retrieve multiple assets using the Relay connection interface"
    assetsConnection(
        after: String,
        before: String,
        first: Int,
        last: Int,
        #First locale matched will be used based on the order of this input
        locales: [Locale!]! = [en],
        orderBy: AssetOrderByInput,
        skip: Int,
        stage: Stage! = PUBLISHED,
        where: AssetWhereInput
    ): AssetConnection!
    "Retrieve a single card"
    card(stage: Stage! = PUBLISHED, where: CardWhereUniqueInput!): Card
    "Retrieve multiple cards"
    cards(after: String, before: String, first: Int, last: Int, orderBy: CardOrderByInput, skip: Int, stage: Stage! = PUBLISHED, where: CardWhereInput): [Card!]!
    "Retrieve multiple cards using the Relay connection interface"
    cardsConnection(after: String, before: String, first: Int, last: Int, orderBy: CardOrderByInput, skip: Int, stage: Stage! = PUBLISHED, where: CardWhereInput): CardConnection!
    "Fetches an object given its ID"
    node(
        #The ID of an object
        id: ID!,
        #First locale matched will be used based on the order of this input
        locales: [Locale!]! = [en],
        stage: Stage! = PUBLISHED
    ): Node
}

"Representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
type RGBA {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

"Custom type representing a rich text value comprising of raw rich text ast, html, markdown and text values"
type RichText {
    "Returns HTMl representation"
    html: String!
    "Returns Markdown representation"
    markdown: String!
    "Returns AST representation"
    raw: RichTextAST!
    "Returns plain-text contents of RichText"
    text: String!
}

enum AgentOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    name_ASC
    name_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum AssetOrderByInput {
    createdAt_ASC
    createdAt_DESC
    fileName_ASC
    fileName_DESC
    handle_ASC
    handle_DESC
    height_ASC
    height_DESC
    id_ASC
    id_DESC
    mimeType_ASC
    mimeType_DESC
    publishedAt_ASC
    publishedAt_DESC
    size_ASC
    size_DESC
    updatedAt_ASC
    updatedAt_DESC
    width_ASC
    width_DESC
}

enum CardOrderByInput {
    createdAt_ASC
    createdAt_DESC
    id_ASC
    id_DESC
    isDrawn_ASC
    isDrawn_DESC
    name_ASC
    name_DESC
    publishedAt_ASC
    publishedAt_DESC
    updatedAt_ASC
    updatedAt_DESC
}

enum DocumentFileTypes {
    doc
    docx
    html
    jpg
    odp
    ods
    odt
    pdf
    png
    ppt
    pptx
    svg
    txt
    webp
    xls
    xlsx
}

enum ImageFit {
    #Resizes the image to fit within the specified parameters without distorting, cropping, or changing the aspect ratio.
    clip
    #Resizes the image to fit the specified parameters exactly by removing any parts of the image that don't fit within the boundaries.
    crop
    #Resizes the image to fit within the parameters, but as opposed to 'fit:clip' will not scale the image if the image is smaller than the output size.
    max
    #Resizes the image to fit the specified parameters exactly by scaling the image to the desired size. The aspect ratio of the image is not respected and the image can be distorted using this method.
    scale
}

"Locale system enumeration"
enum Locale {
    #System locale
    en
}

"Stage system enumeration"
enum Stage {
    #System Draft Stage
    DRAFT
    #System Published Stage
    PUBLISHED
}

enum _FilterKind {
    AND
    NOT
    OR
    contains
    contains_all
    contains_none
    contains_some
    ends_with
    eq
    eq_not
    gt
    gte
    in
    lt
    lte
    not_contains
    not_ends_with
    not_in
    not_starts_with
    relational_every
    relational_none
    relational_single
    relational_some
    search
    starts_with
}

enum _MutationInputFieldKind {
    enum
    relation
    richText
    scalar
    union
    virtual
}

enum _MutationKind {
    create
    delete
    deleteMany
    publish
    publishMany
    unpublish
    unpublishMany
    update
    updateMany
    upsert
}

enum _OrderDirection {
    asc
    desc
}

enum _RelationInputCardinality {
    many
    one
}

enum _RelationInputKind {
    create
    update
}

enum _RelationKind {
    regular
    union
}

input AgentConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: AgentWhereUniqueInput!
}

input AgentCreateInput {
    createdAt: DateTime
    hand: CardCreateManyInlineInput
    name: String!
    updatedAt: DateTime
}

input AgentCreateManyInlineInput {
    "Connect multiple existing Agent documents"
    connect: [AgentWhereUniqueInput!]
    "Create and connect multiple existing Agent documents"
    create: [AgentCreateInput!]
}

input AgentCreateOneInlineInput {
    "Connect one existing Agent document"
    connect: AgentWhereUniqueInput
    "Create and connect one Agent document"
    create: AgentCreateInput
}

"Identifies documents"
input AgentManyWhereInput {
    "Logical AND on all given filters."
    AND: [AgentWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AgentWhereInput!]
    "Logical OR on all given filters."
    OR: [AgentWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    hand_every: CardWhereInput
    hand_none: CardWhereInput
    hand_some: CardWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

input AgentUpdateInput {
    hand: CardUpdateManyInlineInput
    name: String
}

input AgentUpdateManyInlineInput {
    "Connect multiple existing Agent documents"
    connect: [AgentConnectInput!]
    "Create and connect multiple Agent documents"
    create: [AgentCreateInput!]
    "Delete multiple Agent documents"
    delete: [AgentWhereUniqueInput!]
    "Disconnect multiple Agent documents"
    disconnect: [AgentWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Agent documents"
    set: [AgentWhereUniqueInput!]
    "Update multiple Agent documents"
    update: [AgentUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Agent documents"
    upsert: [AgentUpsertWithNestedWhereUniqueInput!]
}

input AgentUpdateManyInput {
    createdAt: DateTime
    updatedAt: DateTime
}

input AgentUpdateManyWithNestedWhereInput {
    "Update many input"
    data: AgentUpdateManyInput!
    "Document search"
    where: AgentWhereInput!
}

input AgentUpdateOneInlineInput {
    "Connect existing Agent document"
    connect: AgentWhereUniqueInput
    "Create and connect one Agent document"
    create: AgentCreateInput
    "Delete currently connected Agent document"
    delete: Boolean
    "Disconnect currently connected Agent document"
    disconnect: Boolean
    "Update single Agent document"
    update: AgentUpdateWithNestedWhereUniqueInput
    "Upsert single Agent document"
    upsert: AgentUpsertWithNestedWhereUniqueInput
}

input AgentUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: AgentUpdateInput!
    "Unique document search"
    where: AgentWhereUniqueInput!
}

input AgentUpsertInput {
    "Create document if it didn't exist"
    create: AgentCreateInput!
    "Update document if it exists"
    update: AgentUpdateInput!
}

input AgentUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: AgentUpsertInput!
    "Unique document search"
    where: AgentWhereUniqueInput!
}

"Identifies documents"
input AgentWhereInput {
    "Logical AND on all given filters."
    AND: [AgentWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AgentWhereInput!]
    "Logical OR on all given filters."
    OR: [AgentWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    hand_every: CardWhereInput
    hand_none: CardWhereInput
    hand_some: CardWhereInput
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

"References Agent record uniquely"
input AgentWhereUniqueInput {
    id: ID
    name: String
}

input AssetConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: AssetWhereUniqueInput!
}

input AssetCreateInput {
    cardImage: CardCreateManyInlineInput
    createdAt: DateTime
    fileName: String!
    handle: String!
    height: Float
    "Inline mutations for managing document localizations excluding the default locale"
    localizations: AssetCreateLocalizationsInput
    mimeType: String
    size: Float
    updatedAt: DateTime
    width: Float
}

input AssetCreateLocalizationDataInput {
    createdAt: DateTime
    fileName: String!
    handle: String!
    height: Float
    mimeType: String
    size: Float
    updatedAt: DateTime
    width: Float
}

input AssetCreateLocalizationInput {
    "Localization input"
    data: AssetCreateLocalizationDataInput!
    locale: Locale!
}

input AssetCreateLocalizationsInput {
    "Create localizations for the newly-created document"
    create: [AssetCreateLocalizationInput!]
}

input AssetCreateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetWhereUniqueInput!]
    "Create and connect multiple existing Asset documents"
    create: [AssetCreateInput!]
}

input AssetCreateOneInlineInput {
    "Connect one existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
}

"Identifies documents"
input AssetManyWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    cardImage_every: CardWhereInput
    cardImage_none: CardWhereInput
    cardImage_some: CardWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

"Transformations for Assets"
input AssetTransformationInput {
    document: DocumentTransformationInput
    image: ImageTransformationInput
    "Pass true if you want to validate the passed transformation parameters"
    validateOptions: Boolean = false
}

input AssetUpdateInput {
    cardImage: CardUpdateManyInlineInput
    fileName: String
    handle: String
    height: Float
    "Manage document localizations"
    localizations: AssetUpdateLocalizationsInput
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateLocalizationDataInput {
    fileName: String!
    handle: String!
    height: Float
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateLocalizationInput {
    data: AssetUpdateLocalizationDataInput!
    locale: Locale!
}

input AssetUpdateLocalizationsInput {
    "Localizations to create"
    create: [AssetCreateLocalizationInput!]
    "Localizations to delete"
    delete: [Locale!]
    "Localizations to update"
    update: [AssetUpdateLocalizationInput!]
    upsert: [AssetUpsertLocalizationInput!]
}

input AssetUpdateManyInlineInput {
    "Connect multiple existing Asset documents"
    connect: [AssetConnectInput!]
    "Create and connect multiple Asset documents"
    create: [AssetCreateInput!]
    "Delete multiple Asset documents"
    delete: [AssetWhereUniqueInput!]
    "Disconnect multiple Asset documents"
    disconnect: [AssetWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Asset documents"
    set: [AssetWhereUniqueInput!]
    "Update multiple Asset documents"
    update: [AssetUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Asset documents"
    upsert: [AssetUpsertWithNestedWhereUniqueInput!]
}

input AssetUpdateManyInput {
    createdAt: DateTime
    "Optional updates to localizations"
    localizations: [AssetUpdateManyLocalizationInput!]
    updatedAt: DateTime
}

input AssetUpdateManyLocalizationInput {
    fileName: String!
    height: Float
    mimeType: String
    size: Float
    width: Float
}

input AssetUpdateManyWithNestedWhereInput {
    "Update many input"
    data: AssetUpdateManyInput!
    "Document search"
    where: AssetWhereInput!
}

input AssetUpdateOneInlineInput {
    "Connect existing Asset document"
    connect: AssetWhereUniqueInput
    "Create and connect one Asset document"
    create: AssetCreateInput
    "Delete currently connected Asset document"
    delete: Boolean
    "Disconnect currently connected Asset document"
    disconnect: Boolean
    "Update single Asset document"
    update: AssetUpdateWithNestedWhereUniqueInput
    "Upsert single Asset document"
    upsert: AssetUpsertWithNestedWhereUniqueInput
}

input AssetUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: AssetUpdateInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

input AssetUpsertInput {
    "Create document if it didn't exist"
    create: AssetCreateInput!
    "Update document if it exists"
    update: AssetUpdateInput!
}

input AssetUpsertLocalizationInput {
    create: AssetCreateLocalizationDataInput!
    locale: Locale!
    update: AssetUpdateLocalizationDataInput!
}

input AssetUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: AssetUpsertInput!
    "Unique document search"
    where: AssetWhereUniqueInput!
}

"Identifies documents"
input AssetWhereInput {
    "Logical AND on all given filters."
    AND: [AssetWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [AssetWhereInput!]
    "Logical OR on all given filters."
    OR: [AssetWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    cardImage_every: CardWhereInput
    cardImage_none: CardWhereInput
    cardImage_some: CardWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    fileName: String
    "All values containing the given string."
    fileName_contains: String
    "All values ending with the given string."
    fileName_ends_with: String
    "All values that are contained in given list."
    fileName_in: [String!]
    "All values that are not equal to given value."
    fileName_not: String
    "All values not containing the given string."
    fileName_not_contains: String
    "All values not ending with the given string"
    fileName_not_ends_with: String
    "All values that are not contained in given list."
    fileName_not_in: [String!]
    "All values not starting with the given string."
    fileName_not_starts_with: String
    "All values starting with the given string."
    fileName_starts_with: String
    handle: String
    "All values containing the given string."
    handle_contains: String
    "All values ending with the given string."
    handle_ends_with: String
    "All values that are contained in given list."
    handle_in: [String!]
    "All values that are not equal to given value."
    handle_not: String
    "All values not containing the given string."
    handle_not_contains: String
    "All values not ending with the given string"
    handle_not_ends_with: String
    "All values that are not contained in given list."
    handle_not_in: [String!]
    "All values not starting with the given string."
    handle_not_starts_with: String
    "All values starting with the given string."
    handle_starts_with: String
    height: Float
    "All values greater than the given value."
    height_gt: Float
    "All values greater than or equal the given value."
    height_gte: Float
    "All values that are contained in given list."
    height_in: [Float!]
    "All values less than the given value."
    height_lt: Float
    "All values less than or equal the given value."
    height_lte: Float
    "All values that are not equal to given value."
    height_not: Float
    "All values that are not contained in given list."
    height_not_in: [Float!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    mimeType: String
    "All values containing the given string."
    mimeType_contains: String
    "All values ending with the given string."
    mimeType_ends_with: String
    "All values that are contained in given list."
    mimeType_in: [String!]
    "All values that are not equal to given value."
    mimeType_not: String
    "All values not containing the given string."
    mimeType_not_contains: String
    "All values not ending with the given string"
    mimeType_not_ends_with: String
    "All values that are not contained in given list."
    mimeType_not_in: [String!]
    "All values not starting with the given string."
    mimeType_not_starts_with: String
    "All values starting with the given string."
    mimeType_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    size: Float
    "All values greater than the given value."
    size_gt: Float
    "All values greater than or equal the given value."
    size_gte: Float
    "All values that are contained in given list."
    size_in: [Float!]
    "All values less than the given value."
    size_lt: Float
    "All values less than or equal the given value."
    size_lte: Float
    "All values that are not equal to given value."
    size_not: Float
    "All values that are not contained in given list."
    size_not_in: [Float!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
    width: Float
    "All values greater than the given value."
    width_gt: Float
    "All values greater than or equal the given value."
    width_gte: Float
    "All values that are contained in given list."
    width_in: [Float!]
    "All values less than the given value."
    width_lt: Float
    "All values less than or equal the given value."
    width_lte: Float
    "All values that are not equal to given value."
    width_not: Float
    "All values that are not contained in given list."
    width_not_in: [Float!]
}

"References Asset record uniquely"
input AssetWhereUniqueInput {
    id: ID
}

input CardConnectInput {
    "Allow to specify document position in list of connected documents, will default to appending at end of list"
    position: ConnectPositionInput
    "Document to connect"
    where: CardWhereUniqueInput!
}

input CardCreateInput {
    agent: AgentCreateOneInlineInput
    createdAt: DateTime
    image: AssetCreateOneInlineInput
    isDrawn: Boolean!
    name: String!
    updatedAt: DateTime
}

input CardCreateManyInlineInput {
    "Connect multiple existing Card documents"
    connect: [CardWhereUniqueInput!]
    "Create and connect multiple existing Card documents"
    create: [CardCreateInput!]
}

input CardCreateOneInlineInput {
    "Connect one existing Card document"
    connect: CardWhereUniqueInput
    "Create and connect one Card document"
    create: CardCreateInput
}

"Identifies documents"
input CardManyWhereInput {
    "Logical AND on all given filters."
    AND: [CardWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [CardWhereInput!]
    "Logical OR on all given filters."
    OR: [CardWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    agent: AgentWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    image: AssetWhereInput
    isDrawn: Boolean
    "All values that are not equal to given value."
    isDrawn_not: Boolean
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

input CardUpdateInput {
    agent: AgentUpdateOneInlineInput
    image: AssetUpdateOneInlineInput
    isDrawn: Boolean
    name: String
}

input CardUpdateManyInlineInput {
    "Connect multiple existing Card documents"
    connect: [CardConnectInput!]
    "Create and connect multiple Card documents"
    create: [CardCreateInput!]
    "Delete multiple Card documents"
    delete: [CardWhereUniqueInput!]
    "Disconnect multiple Card documents"
    disconnect: [CardWhereUniqueInput!]
    "Override currently-connected documents with multiple existing Card documents"
    set: [CardWhereUniqueInput!]
    "Update multiple Card documents"
    update: [CardUpdateWithNestedWhereUniqueInput!]
    "Upsert multiple Card documents"
    upsert: [CardUpsertWithNestedWhereUniqueInput!]
}

input CardUpdateManyInput {
    createdAt: DateTime
    isDrawn: Boolean!
    updatedAt: DateTime
}

input CardUpdateManyWithNestedWhereInput {
    "Update many input"
    data: CardUpdateManyInput!
    "Document search"
    where: CardWhereInput!
}

input CardUpdateOneInlineInput {
    "Connect existing Card document"
    connect: CardWhereUniqueInput
    "Create and connect one Card document"
    create: CardCreateInput
    "Delete currently connected Card document"
    delete: Boolean
    "Disconnect currently connected Card document"
    disconnect: Boolean
    "Update single Card document"
    update: CardUpdateWithNestedWhereUniqueInput
    "Upsert single Card document"
    upsert: CardUpsertWithNestedWhereUniqueInput
}

input CardUpdateWithNestedWhereUniqueInput {
    "Document to update"
    data: CardUpdateInput!
    "Unique document search"
    where: CardWhereUniqueInput!
}

input CardUpsertInput {
    "Create document if it didn't exist"
    create: CardCreateInput!
    "Update document if it exists"
    update: CardUpdateInput!
}

input CardUpsertWithNestedWhereUniqueInput {
    "Upsert data"
    data: CardUpsertInput!
    "Unique document search"
    where: CardWhereUniqueInput!
}

"Identifies documents"
input CardWhereInput {
    "Logical AND on all given filters."
    AND: [CardWhereInput!]
    "Logical NOT on all given filters combined by AND."
    NOT: [CardWhereInput!]
    "Logical OR on all given filters."
    OR: [CardWhereInput!]
    "Contains search across all appropriate fields."
    _search: String
    agent: AgentWhereInput
    createdAt: DateTime
    "All values greater than the given value."
    createdAt_gt: DateTime
    "All values greater than or equal the given value."
    createdAt_gte: DateTime
    "All values that are contained in given list."
    createdAt_in: [DateTime!]
    "All values less than the given value."
    createdAt_lt: DateTime
    "All values less than or equal the given value."
    createdAt_lte: DateTime
    "All values that are not equal to given value."
    createdAt_not: DateTime
    "All values that are not contained in given list."
    createdAt_not_in: [DateTime!]
    id: ID
    "All values containing the given string."
    id_contains: ID
    "All values ending with the given string."
    id_ends_with: ID
    "All values that are contained in given list."
    id_in: [ID!]
    "All values that are not equal to given value."
    id_not: ID
    "All values not containing the given string."
    id_not_contains: ID
    "All values not ending with the given string"
    id_not_ends_with: ID
    "All values that are not contained in given list."
    id_not_in: [ID!]
    "All values not starting with the given string."
    id_not_starts_with: ID
    "All values starting with the given string."
    id_starts_with: ID
    image: AssetWhereInput
    isDrawn: Boolean
    "All values that are not equal to given value."
    isDrawn_not: Boolean
    name: String
    "All values containing the given string."
    name_contains: String
    "All values ending with the given string."
    name_ends_with: String
    "All values that are contained in given list."
    name_in: [String!]
    "All values that are not equal to given value."
    name_not: String
    "All values not containing the given string."
    name_not_contains: String
    "All values not ending with the given string"
    name_not_ends_with: String
    "All values that are not contained in given list."
    name_not_in: [String!]
    "All values not starting with the given string."
    name_not_starts_with: String
    "All values starting with the given string."
    name_starts_with: String
    publishedAt: DateTime
    "All values greater than the given value."
    publishedAt_gt: DateTime
    "All values greater than or equal the given value."
    publishedAt_gte: DateTime
    "All values that are contained in given list."
    publishedAt_in: [DateTime!]
    "All values less than the given value."
    publishedAt_lt: DateTime
    "All values less than or equal the given value."
    publishedAt_lte: DateTime
    "All values that are not equal to given value."
    publishedAt_not: DateTime
    "All values that are not contained in given list."
    publishedAt_not_in: [DateTime!]
    updatedAt: DateTime
    "All values greater than the given value."
    updatedAt_gt: DateTime
    "All values greater than or equal the given value."
    updatedAt_gte: DateTime
    "All values that are contained in given list."
    updatedAt_in: [DateTime!]
    "All values less than the given value."
    updatedAt_lt: DateTime
    "All values less than or equal the given value."
    updatedAt_lte: DateTime
    "All values that are not equal to given value."
    updatedAt_not: DateTime
    "All values that are not contained in given list."
    updatedAt_not_in: [DateTime!]
}

"References Card record uniquely"
input CardWhereUniqueInput {
    id: ID
    name: String
}

"Accepts either HEX or RGBA color value. At least one of hex or rgba value should be passed. If both are passed RGBA is used."
input ColorInput {
    hex: Hex
    rgba: RGBAInput
}

input ConnectPositionInput {
    "Connect document after specified document"
    after: ID
    "Connect document before specified document"
    before: ID
    "Connect document at last position"
    end: Boolean
    "Connect document at first position"
    start: Boolean
}

input DocumentOutputInput {
    """
    Transforms a document into a desired file type.
    See this matrix for format support:

    PDF:\tjpg, odp, ods, odt, png, svg, txt, and webp
    DOC:\tdocx, html, jpg, odt, pdf, png, svg, txt, and webp
    DOCX:\tdoc, html, jpg, odt, pdf, png, svg, txt, and webp
    ODT:\tdoc, docx, html, jpg, pdf, png, svg, txt, and webp
    XLS:\tjpg, pdf, ods, png, svg, xlsx, and webp
    XLSX:\tjpg, pdf, ods, png, svg, xls, and webp
    ODS:\tjpg, pdf, png, xls, svg, xlsx, and webp
    PPT:\tjpg, odp, pdf, png, svg, pptx, and webp
    PPTX:\tjpg, odp, pdf, png, svg, ppt, and webp
    ODP:\tjpg, pdf, png, ppt, svg, pptx, and webp
    BMP:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    GIF:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    JPG:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    PNG:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    WEBP:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    TIFF:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    AI:\t    jpg, odp, ods, odt, pdf, png, svg, and webp
    PSD:\tjpg, odp, ods, odt, pdf, png, svg, and webp
    SVG:\tjpg, odp, ods, odt, pdf, png, and webp
    HTML:\tjpg, odt, pdf, svg, txt, and webp
    TXT:\tjpg, html, odt, pdf, svg, and webp
    """
    format: DocumentFileTypes
}

"Transformations for Documents"
input DocumentTransformationInput {
    "Changes the output for the file."
    output: DocumentOutputInput
}

input ImageResizeInput {
    "The default value for the fit parameter is fit:clip."
    fit: ImageFit
    "The height in pixels to resize the image to. The value must be an integer from 1 to 10000."
    height: Int
    "The width in pixels to resize the image to. The value must be an integer from 1 to 10000."
    width: Int
}

"Transformations for Images"
input ImageTransformationInput {
    "Resizes the image"
    resize: ImageResizeInput
}

"Input for a geolocation point with latitude and longitude"
input LocationInput {
    latitude: Float!
    longitude: Float!
}

input PublishLocaleInput {
    "Locales to publish"
    locale: Locale!
    "Stages to publish selected locales to"
    stages: [Stage!]!
}

"Input type representing a RGBA color value: https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#rgb()_and_rgba()"
input RGBAInput {
    a: RGBATransparency!
    b: RGBAHue!
    g: RGBAHue!
    r: RGBAHue!
}

input UnpublishLocaleInput {
    "Locales to unpublish"
    locale: Locale!
    "Stages to unpublish selected locales from"
    stages: [Stage!]!
}


"Slate-compatible RichText AST"
scalar RichTextAST

scalar Hex

"Raw JSON value"
scalar Json

"The Long scalar type represents non-fractional signed whole numeric values. Long can represent values between -(2^63) and 2^63 - 1."
scalar Long

"A date-time string at UTC, such as 2007-12-03T10:15:30Z, compliant with the date-timeformat outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representationof dates and times using the Gregorian calendar."
scalar DateTime

"A date string, such as 2007-12-03 (YYYY-MM-DD), compliant with ISO 8601 standard for representation of dates using the Gregorian calendar."
scalar Date

scalar RGBAHue

scalar RGBATransparency